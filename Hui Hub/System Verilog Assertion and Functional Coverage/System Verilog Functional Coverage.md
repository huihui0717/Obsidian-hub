
# Chapter 25
# Functional Coverage


    引言：这是关于功能覆盖的介绍性章节，它是SystemVerilog保护伞下的一种独特语言。我们将看到功能覆盖和方法的不同组成部分。


啊，所以你已经做了一切检查设计。但你做了什么来检查你的测试台？你怎么知道你的测试台确实涵盖了所有需要涵盖的内容？这就是功能覆盖范围的特点。但首先，让我们确保我们理解好的旧代码覆盖(Code Coverage)和新功能覆盖(Functional Coverage)方法之间的区别。
注意，功能覆盖和受限随机验证(CRV)是并行的。你需要知道功能覆盖的差距，并根据这些差距，限制输入激励仅针对这些差距。
功能覆盖的起源可以追溯到20世纪90年代，当时出现了约束随机模拟。显然，受限随机刺激生成的一个价值主张是，模拟环境可以自动生成数千个测试，通常需要大量的手动工作来创建定向测试。然而，受限随机激励生成的一个问题是，如果没有在模拟运行后检查波形的繁琐工作，您永远无法准确知道测试了哪些功能。因此，功能覆盖被发明为一种测量，以帮助准确确定模拟回归测试的功能，而无需对波形进行目视检查。
目前，功能覆盖的采用不限于受限的随机模拟环境。事实上，功能覆盖提供了在模拟期间执行需求跟踪的自动方法，这通常是DO-254合规性检查所需的关键步骤。例如，功能覆盖可以通过链接到规范中定义的特定需求的机制来实现。然后，在模拟运行之后，可以自动测量通过特定的定向或约束随机测试检查的需求，以及自动确定从未测试过的需求。

## 25.1 代码覆盖率和功能覆盖率之间的差别

### 25.1.1 代码覆盖率

$直接源自设计规范；不是用户指定的。$代码覆盖的优点之一是它自动描述了程序的源代码在测试期间被激活的程度，从而识别了源代码中在测试期间未被激活的结构。与功能覆盖不同，代码覆盖的关键好处之一是创建结构覆盖模型是一个自动过程。因此，将代码覆盖范围集成到现有的模拟流中是很容易的，并且不需要更改当前的设计或验证方法。
- 评估是否覆盖了设计结构（即，行、切换、赋值、分支、表达式、状态和状态转换）
- 但，不评估设计意图
    —  如果用户指定  busGnt = busReq && (idle || !(reset));
    —  而不是真正的意图 busGnt = busReq && (idle && !(reset));

      代码覆盖率不会抓住它。为了达到目的，您需要一个强大的测试台来排除功能性错误，并提供一种客观预测测试台的健壮程度的方法。

下面是代码覆盖目标（结构上）的简要快照。您可以参考EDA供应商提供的代码覆盖手册以进行进一步分析。以下是(Mentor) Mentor。















