
# Chapter 25
# Functional Coverage


    引言：这是关于功能覆盖的介绍性章节，它是SystemVerilog保护伞下的一种独特语言。我们将看到功能覆盖和方法的不同组成部分。


啊，所以你已经做了一切检查设计。但你做了什么来检查你的测试台？你怎么知道你的测试台确实涵盖了所有需要涵盖的内容？这就是功能覆盖范围的特点。但首先，让我们确保我们理解好的旧代码覆盖(Code Coverage)和新功能覆盖(Functional Coverage)方法之间的区别。
注意，功能覆盖和受限随机验证(CRV)是并行的。你需要知道功能覆盖的差距，并根据这些差距，限制输入激励仅针对这些差距。

功能覆盖的起源可以追溯到20世纪90年代，当时出现了约束随机模拟。显然，受限随机刺激生成的一个价值主张是，模拟环境可以自动生成数千个测试，通常需要大量的手动工作来创建定向测试。然而，受限随机激励生成的一个问题是，如果没有在模拟运行后检查波形的繁琐工作，您永远无法准确知道测试了哪些功能。因此，功能覆盖被发明为一种测量，以帮助准确确定模拟回归测试的功能，而无需对波形进行目视检查。

目前，功能覆盖的采用不限于受限的随机模拟环境。事实上，功能覆盖提供了在模拟期间执行需求跟踪的自动方法，这通常是DO-254合规性检查所需的关键步骤。例如，功能覆盖可以通过链接到规范中定义的特定需求的机制来实现。然后，在模拟运行之后，可以自动测量通过特定的定向或约束随机测试检查的需求，以及自动确定从未测试过的需求。

## 25.1 代码覆盖率和功能覆盖率之间的差别

### 25.1.1 代码覆盖率

$直接源自设计规范；不是用户指定的。$代码覆盖的优点之一是它自动描述了程序的源代码在测试期间被激活的程度，从而识别了源代码中在测试期间未被激活的结构。与功能覆盖不同，代码覆盖的关键好处之一是创建结构覆盖模型是一个自动过程。因此，将代码覆盖范围集成到现有的模拟流中是很容易的，并且不需要更改当前的设计或验证方法。
- 评估是否覆盖了设计结构（即，行、切换、赋值、分支、表达式、状态和状态转换）
- 但，不评估设计意图
    —  如果用户指定  busGnt = busReq && (idle || !(reset));
    —  而不是真正的意图 busGnt = busReq && (idle && !(reset));

      代码覆盖率不会抓住它。为了达到目的，您需要一个强大的测试台来排除功能性错误，并提供一种客观预测测试台的健壮程度的方法。

下面是代码覆盖目标（结构上）的简要快照。您可以参考EDA供应商提供的代码覆盖手册以进行进一步分析。以下是(Mentor) Mentor's Verfiaction Academy Coverage Cookbook。

#### Line Coverage

行覆盖率是一个代码覆盖率度量，我们使用它来确定在模拟期间执行了源代码的哪些行。行覆盖率度量报告将具有与每行源代码相关联的计数，指示该行已执行的总次数。行执行计数值不仅对识别从未执行过的源代码行有用，而且在工程师认为需要最小的行执行阈值来实现充分测试时也有用。

行覆盖率分析通常会发现，由于缺少输入激励，激活一行代码所需的罕见条件尚未发生。或者，行覆盖率分析可能会发现源代码的数据和控制流阻止了它，原因可能是代码中的错误，或者是某些IP配置下当前不需要的死代码。对于未使用或失效的代码，您可以选择在覆盖率记录和报告步骤中排除或过滤此代码，这允许您只关注相关代码。

#### Statement Coverage

语句覆盖率是一个代码覆盖率度量，我们使用它来确定在模拟期间源代码中执行了哪些语句。一般来说，大多数工程师发现语句覆盖率分析比行覆盖率更有用，因为一个语句通常跨越多行源代码，或者多个语句可以出现在一行源代码上。

用于语句覆盖率分析的度量报告将具有与每行源代码相关联的计数，指示语句已执行的总次数。该语句执行计数值不仅用于识别从未执行过的源代码行，而且在工程师认为需要最小语句执行阈值以实现充分测试时也很有用。

#### Block Coverage

块覆盖率是语句覆盖率度量的一个变体，它标识代码块是否已执行。块被定义为条件语句之间或过程定义内的一组语句，关键点是如果到达块，则将执行块内的所有行。此度量用于避免不道德的工程师通过向代码中添加更多语句来实现更高的语句覆盖率。

#### Branch Coverage

分支覆盖率（也称为决策覆盖率）是一种代码覆盖率度量，它报告在控制结构（如if、case、while、repeat、forever、for和循环语句）中测试的布尔表达式的评估结果是否为真或假。整个布尔表达式被视为一个真或假谓词，无论它是否包含逻辑运算符或逻辑运算符。

#### Expression Coverage

表达式覆盖率（有时称为条件覆盖率）是一种代码覆盖率度量，用于确定每个条件的计算结果是否同时为真和假。条件是不包含逻辑运算符的布尔操作数。因此，表达式覆盖率彼此独立地测量布尔条件。

#### Finite-State Machine Coverage

今天的代码覆盖工具可以识别RTL源代码中的有限状态机。因此，这使得可以自动提取FSM代码覆盖度量来测量条件。例如，状态机的每个状态被输入的次数，FSM从一个状态转换到其相邻状态的次数，甚至是识别状态访问转换的顺序弧覆盖。

### 25.1.2 功能覆盖率

功能覆盖背后的想法是，我们已经覆盖了设计的意图。我们是否涵盖了设计规范要求的所有内容？例如，您可能拥有100%的代码覆盖率，但功能覆盖率只能是50%。仅覆盖RTL代码的结构（代码覆盖）并不能保证我们在功能上覆盖了RTL实际打算设计的内容。在这种情况下，显然不能自动创建功能覆盖矩阵。必须仔细研究设计规范，并使用“covergroup”、“coverpoint”、“bins”等手动创建功能覆盖矩阵。

所以，功能覆盖率：
- 用户指定；确定需要功能覆盖的设计规范的特征。手动过程。
- 基于设计规范。
- 测量设计意图的覆盖范围。
- 控制导向的覆盖
	— 我是否已执行了所有可能的读取周期支持协议（突发、非突发等）？
	— 过渡覆盖
		我们是否发布了访问Byte后接Qword后接多个Qword的事务？（使用SystemVerilog过渡覆盖）。
		写入L2之后是从同一地址读取（反之亦然）。
			同样，过渡覆盖范围将帮助您确定是否已满足此条件。
	— 交叉覆盖
		标记和数据错误必须同时注入（使用SystemVerilog交叉覆盖）
- 数据导向的覆盖
	— 我们是否访问了所有粒度级别的缓存线（奇数字节、偶数字节、字、四字、全缓存线等）？

## 25.2 基于断言的验证（ABV）和基于功能覆盖（FC）的方法

首先，让我们检查SystemVerilog语言中有助于功能覆盖的组件。

第一个组件是与断言关联的“cover”语句。这个“覆盖”声明允许我们测量==时域==功能覆盖。回想一下，“assert”检查设计中的失败，“cover”查看属性是否得到了行使（即得到了覆盖）。单纯的组合覆盖是不够的。我所说的“低级”时域条件（又称结构序列条件），例如每个req后面都应该跟着gnt。如果这个断言没有失败，可能是因为逻辑是正确的，或者您从未真正断言过“req”。“cover”完成了这个故事。我们“cover”了与我们“assert”完全相同的属性。在req/gnt示例中，如果“覆盖”通过，我们知道该属性确实得到了执行（即，它得到了覆盖），并且没有失败。

第二部分是功能覆盖语言，这是整个部分的要点。功能覆盖允许您通过所谓的覆盖点和覆盖组指定要覆盖的“功能”。更重要的是，它还允许您测量过渡以及交叉覆盖，以确保我们确实覆盖了设计的更精细的细节。本节将澄清这一切。

图25.1显示了SystemVerilog的不同组件以及代码覆盖范围，所有这些都联系在一起，以确定设计是否确实得到了完全验证。

重申一下，SystemVerilog提供了两种类型的覆盖（代码覆盖独立于SystemVerilog）。一个是“cover”属性特性，另一个是功能覆盖语言特性（covergroup、coverpoint、bin等）
![25.1][Img/25.1.png]
                    **Fig.25.1**  基于断言的验证（ABV）和基于功能覆盖（FC）的方法

## 25.3 “cover” 属性，“cover” 序列

功能覆盖方法的第一个组成部分是 “cover”（SystemVerilog断言语言的一部分）。正如我们在第3章中看到的，“cover”使用**SVA时态语法**。有关详细概述，请参阅该部分。以下只是一个概述。



