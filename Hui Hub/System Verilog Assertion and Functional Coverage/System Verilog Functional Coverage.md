
# Chapter 25
# Functional Coverage


    引言：这是关于功能覆盖的介绍性章节，它是SystemVerilog保护伞下的一种独特语言。我们将看到功能覆盖和方法的不同组成部分。


啊，所以你已经做了一切检查设计。但你做了什么来检查你的测试台？你怎么知道你的测试台确实涵盖了所有需要涵盖的内容？这就是功能覆盖范围的特点。但首先，让我们确保我们理解好的旧代码覆盖(Code Coverage)和新功能覆盖(Functional Coverage)方法之间的区别。
注意，功能覆盖和受限随机验证(CRV)是并行的。你需要知道功能覆盖的差距，并根据这些差距，限制输入激励仅针对这些差距。

功能覆盖的起源可以追溯到20世纪90年代，当时出现了约束随机模拟。显然，受限随机刺激生成的一个价值主张是，模拟环境可以自动生成数千个测试，通常需要大量的手动工作来创建定向测试。然而，受限随机激励生成的一个问题是，如果没有在模拟运行后检查波形的繁琐工作，您永远无法准确知道测试了哪些功能。因此，功能覆盖被发明为一种测量，以帮助准确确定模拟回归测试的功能，而无需对波形进行目视检查。

目前，功能覆盖的采用不限于受限的随机模拟环境。事实上，功能覆盖提供了在模拟期间执行需求跟踪的自动方法，这通常是DO-254合规性检查所需的关键步骤。例如，功能覆盖可以通过链接到规范中定义的特定需求的机制来实现。然后，在模拟运行之后，可以自动测量通过特定的定向或约束随机测试检查的需求，以及自动确定从未测试过的需求。

## 25.1 代码覆盖率和功能覆盖率之间的差别

### 25.1.1 代码覆盖率

$直接源自设计规范；不是用户指定的。$代码覆盖的优点之一是它自动描述了程序的源代码在测试期间被激活的程度，从而识别了源代码中在测试期间未被激活的结构。与功能覆盖不同，代码覆盖的关键好处之一是创建结构覆盖模型是一个自动过程。因此，将代码覆盖范围集成到现有的模拟流中是很容易的，并且不需要更改当前的设计或验证方法。
- 评估是否覆盖了设计结构（即，行、切换、赋值、分支、表达式、状态和状态转换）
- 但，不评估设计意图
    —  如果用户指定  busGnt = busReq && (idle || !(reset));
    —  而不是真正的意图 busGnt = busReq && (idle && !(reset));

      代码覆盖率不会抓住它。为了达到目的，您需要一个强大的测试台来排除功能性错误，并提供一种客观预测测试台的健壮程度的方法。

下面是代码覆盖目标（结构上）的简要快照。您可以参考EDA供应商提供的代码覆盖手册以进行进一步分析。以下是(Mentor) Mentor's Verfiaction Academy Coverage Cookbook。

#### Line Coverage

行覆盖率是一个代码覆盖率度量，我们使用它来确定在模拟期间执行了源代码的哪些行。行覆盖率度量报告将具有与每行源代码相关联的计数，指示该行已执行的总次数。行执行计数值不仅对识别从未执行过的源代码行有用，而且在工程师认为需要最小的行执行阈值来实现充分测试时也有用。

行覆盖率分析通常会发现，由于缺少输入激励，激活一行代码所需的罕见条件尚未发生。或者，行覆盖率分析可能会发现源代码的数据和控制流阻止了它，原因可能是代码中的错误，或者是某些IP配置下当前不需要的死代码。对于未使用或失效的代码，您可以选择在覆盖率记录和报告步骤中排除或过滤此代码，这允许您只关注相关代码。

#### Statement Coverage

语句覆盖率是一个代码覆盖率度量，我们使用它来确定在模拟期间源代码中执行了哪些语句。一般来说，大多数工程师发现语句覆盖率分析比行覆盖率更有用，因为一个语句通常跨越多行源代码，或者多个语句可以出现在一行源代码上。

用于语句覆盖率分析的度量报告将具有与每行源代码相关联的计数，指示语句已执行的总次数。该语句执行计数值不仅用于识别从未执行过的源代码行，而且在工程师认为需要最小语句执行阈值以实现充分测试时也很有用。

#### Block Coverage

块覆盖率是语句覆盖率度量的一个变体，它标识代码块是否已执行。块被定义为条件语句之间或过程定义内的一组语句，关键点是如果到达块，则将执行块内的所有行。此度量用于避免不道德的工程师通过向代码中添加更多语句来实现更高的语句覆盖率。

#### Branch Coverage

分支覆盖率（也称为决策覆盖率）是一种代码覆盖率度量，它报告在控制结构（如if、case、while、repeat、forever、for和循环语句）中测试的布尔表达式的评估结果是否为真或假。整个布尔表达式被视为一个真或假谓词，无论它是否包含逻辑运算符或逻辑运算符。

#### Expression Coverage

表达式覆盖率（有时称为条件覆盖率）是一种代码覆盖率度量，用于确定每个条件的计算结果是否同时为真和假。条件是不包含逻辑运算符的布尔操作数。因此，表达式覆盖率彼此独立地测量布尔条件。

#### Finite-State Machine Coverage

今天的代码覆盖工具可以识别RTL源代码中的有限状态机。因此，这使得可以自动提取FSM代码覆盖度量来测量条件。例如，状态机的每个状态被输入的次数，FSM从一个状态转换到其相邻状态的次数，甚至是识别状态访问转换的顺序弧覆盖。

### 25.1.2 功能覆盖率

功能覆盖背后的想法是，我们已经覆盖了设计的意图。我们是否涵盖了设计规范要求的所有内容？例如，您可能拥有100%的代码覆盖率，但功能覆盖率只能是50%。仅覆盖RTL代码的结构（代码覆盖）并不能保证我们在功能上覆盖了RTL实际打算设计的内容。在这种情况下，显然不能自动创建功能覆盖矩阵。必须仔细研究设计规范，并使用“covergroup”、“coverpoint”、“bins”等手动创建功能覆盖矩阵。

所以，功能覆盖率：
- 用户指定；确定需要功能覆盖的设计规范的特征。手动过程。
- 基于设计规范。
- 测量设计意图的覆盖范围。
- 控制导向的覆盖
	— 我是否已执行了所有可能的读取周期支持协议（突发、非突发等）？
	— 过渡覆盖
		我们是否发布了访问Byte后接Qword后接多个Qword的事务？（使用SystemVerilog过渡覆盖）。
		写入L2之后是从同一地址读取（反之亦然）。
			同样，过渡覆盖范围将帮助您确定是否已满足此条件。
	— 交叉覆盖
		标记和数据错误必须同时注入（使用SystemVerilog交叉覆盖）
- 数据导向的覆盖
	— 我们是否访问了所有粒度级别的缓存线（奇数字节、偶数字节、字、四字、全缓存线等）？

## 25.2 基于断言的验证（ABV）和基于功能覆盖（FC）的方法

首先，让我们检查SystemVerilog语言中有助于功能覆盖的组件。

第一个组件是与断言关联的“cover”语句。这个“覆盖”声明允许我们测量==时域==功能覆盖。回想一下，“assert”检查设计中的失败，“cover”查看属性是否得到了行使（即得到了覆盖）。单纯的组合覆盖是不够的。我所说的“低级”时域条件（又称结构序列条件），例如每个req后面都应该跟着gnt。如果这个断言没有失败，可能是因为逻辑是正确的，或者您从未真正断言过“req”。“cover”完成了这个故事。我们“cover”了与我们“assert”完全相同的属性。在req/gnt示例中，如果“覆盖”通过，我们知道该属性确实得到了执行（即，它得到了覆盖），并且没有失败。

第二部分是功能覆盖语言，这是整个部分的要点。功能覆盖允许您通过所谓的覆盖点和覆盖组指定要覆盖的“功能”。更重要的是，它还允许您测量过渡以及交叉覆盖，以确保我们确实覆盖了设计的更精细的细节。本节将澄清这一切。

图25.1显示了SystemVerilog的不同组件以及代码覆盖范围，所有这些都联系在一起，以确定设计是否确实得到了完全验证。

重申一下，SystemVerilog提供了两种类型的覆盖（代码覆盖独立于SystemVerilog）。一个是“cover”属性特性，另一个是功能覆盖语言特性（covergroup、coverpoint、bin等）
![25.1][Img/25.1.png]
                    **Fig.25.1**  基于断言的验证（ABV）和基于功能覆盖（FC）的方法

## 25.3 “cover” 属性，“cover” 序列

功能覆盖方法的第一个组成部分是 “cover”（SystemVerilog断言语言的一部分）。正如我们在第3章中看到的，“cover”使用**SVA时态语法**。有关详细概述，请参阅该部分。以下只是一个概述。
- (a) “cover”基本上是“assert”的影子。换句话说，您可以获得双倍的里程，因为相同的属性可以用于断言和在结构级别收集功能覆盖。
- (b) 无法从System Verilog 代码访问 “cover”。
- (c) "cover" 仅适用于结构设计。
- (d) “cover”提供结构级时域序列覆盖。它只能放在模块、程序和接口中。不能放在“类”中。
- (e) 有两种类型的“cover”。如第节所述。3.1和3.2，一个是 cover property，另一个是 cover sequence。cover property 的主体可能包含任意属性，如并发断言和假设。另一方面，cover sequence的主体仅限于一个序列。参见第节。6.16序列和属性之间的差异。

## 25.4 “covergroup” (With Is "coverpoints", "bins" etc)

功能覆盖方法的第二个组成部分基于功能覆盖语言的 covergroup、coverpoints、bins等。

- (a) covergroup 提供设计变量的覆盖范围。它们记录指定为覆盖点（设计变量）的各种值的出现次数。
- (b) 这些 coverpoint 可以由您的测试用例或测试台分层引用，以便您可以查询某些值或场景。
- (c) 提供覆盖点的“交叉”。
- (d) 可通过 System Verilog 代码和测试用例访问。
- (e) 可放置在"基于类的对象" 或结构代码中。

## 25.5 功能覆盖的方法论

从项目方法论的角度来看，这里还有一些观点。

- 您的测试计划（显然）基于您想要测试的功能（即，覆盖）。
- 因此，根据您的测试计划创建一个功能覆盖矩阵，其中包括您要测试的每个功能（控制和数据）。
	 — 在此矩阵中确定所有功能覆盖组/覆盖点（稍后将提供更多信息）。
	 —  在验证/模拟过程中测量其覆盖范围。
	 — 您甚至可以直接从覆盖率报告自动更新矩阵。该方法如图25.2所示。
- 从覆盖率报告中衡量测试的有效性。重申我们刚才讨论的内容，因为以下几点确实是功能覆盖范围允许您完成的要点。
	 — 例如，如果您的测试主要访问缓存行中的32字节颗粒，您将看到字节、字、四字覆盖率低或未覆盖。更改或添加新测试以命中字节/单词等。使用受限随机方法缩小测试目标。约束随机是一种非常强大的方法，与功能覆盖齐头并进。受约束的随机性超出了本书的范围。
	 — 或者测试不触发访问Byte后接Qword后接多个Qword的事务。用过渡覆盖率检查此项。
	 — 或者标记和数据错误必须同时注入（标记和数据误差之间的交叉覆盖）。
- “cover” 时域断言。
- 并通过设计为关键功能路径添加更多覆盖点。
	 — 例如，写入L2之后是从同一地址读取，这在所有可能的写入/读取组合中从两个处理器发生。
- 请记住，在验证过程中更新您的功能覆盖计划。
	 — 仅仅因为您在项目开始时创建了一个计划，并不意味着它本身就是一个目标。
	 — 随着您对设计及其角落案例的了解的增加，您的测试计划和功能覆盖计划的完整性也会随之增加。
	 — 继续为开始时没有想到的任何功能添加覆盖点。
![25.2][Img/25.2.png]
                  Fig. 25.2 Assertions and Coverage based verification methodology—I
![25.3][Img/25.3.png]
                 Fig.25.3 Assertions and Coverage based verification methodology—II
                 
      图25.2和25.3显示了断言和覆盖率驱动的方法。
1.对于属性中的每个“assert”，都有一个相关的“cover”。为属性提供有意义的名称并断言标签。
2.创建一个属性表，该表自动读入断言并创建一个失败/覆盖矩阵。如果断言失败，那么填写FAIL列。如果没有，如果被覆盖，请填写“覆盖”列。我们如何填写此矩阵？阅读...
3.使用covergroup和coverpoint创建功能覆盖计划。同样，为covergroup和coverpoint提供有意义的名称。
4.创建覆盖表，该表自动从步骤3中导出覆盖组/覆盖点名称，并为“覆盖”结果创建矩阵。该矩阵适用于那些未被断言“cover”覆盖，也未被代码覆盖的函数。因此，您需要仔细设计覆盖组和覆盖点。
5.使用断言和功能覆盖组模拟您的设计。
6.模拟将创建一个“覆盖数据库”。该数据库包含有关失败断言和“覆盖”属性以及覆盖的覆盖组和覆盖点的所有信息。
7.使用EDA供应商提供的API，切换此数据库并更新属性表和覆盖率表。
8.循环上述内容。

这种方法的优点是，您可以不断地知道您是否在不增加覆盖范围的情况下旋转车轮。没有这种持续的测量，你可以继续模拟；错误不会被报告；你开始感到舒适，但后来才意识到功能覆盖确实不足。你基本上是一次又一次地运行以相同逻辑为目标的测试。如果您有一个如上所述的方法，您将正确地了解要针对什么功能逻辑来提高错误率。

## 25.6 Follow the Bugs!!

- 那么，你什么时候开始收集保险？
	 — 代码和功能覆盖增加了模拟开销。
	 — 因此，不要在项目的“开始”就打开代码/功能覆盖。
	 — 但项目的“开始”意味着什么？什么时候“结束“和”开始“？
- 这就是Bugs出现的地方！
	 — 创建Bug报告图表
	 — 在“开始”期间，错误率会很高。所有低垂的水果都在采摘☺
	 — 当错误率开始下降时；“开始”已经到了“结束”
	 — 此时，您现有的测试策略将失去动力☹
	 — 这是您开始代码和功能覆盖范围以确定的时候
		 如果新的测试只是重复执行相同的逻辑，那么逻辑的哪一部分还没有涵盖
	 — 为未覆盖的功能开发测试。使用约束随机方法。
	 — 您的错误率将再次上升（保证！☺).

# Chapter 26
# 功能覆盖：语言特性








简介：本章涵盖了整个“功能覆盖”语言。我们将在接下来的章节中介绍以下功能。
1.变量和表达式的覆盖组和覆盖点
2.自动和用户定义的覆盖箱
3.过渡覆盖的箱
4.”wildcard bins“，”illegal bins“ 和 ”ignore bins“
5.交叉覆盖
6.覆盖选项(option)
7.灵活的覆盖采样——event，sequences，procedural
8.控制和查询覆盖率的指令
9.基于SystemVerilog  "类"的功能覆盖
10.应用：覆盖方法和覆盖方法的程序激活






## 26.1 Covergroup/Coverpoint

### 26.1.1 什么是覆盖组

“covergroup”是一种用户定义的类型，允许您对在同一时钟（采样）边缘采样的所有变量/转换/交叉进行集体采样。
- “covergroup”构造封装了覆盖模型的规范。
- “covergroup”可以在“package”、“module”、“program”、“interface”或“class”中定义。
- 可通过SystemVerilog代码和测试用例访问。

### 26.1.2 什么是覆盖点

- 覆盖点是在功能上覆盖设计参数（reg、逻辑、枚举等）的变量或表
- 每个覆盖点包括与其采样值或其值转换相关联的一组箱。
- 所谓的”bins/箱“可以由用户定义或由EDA工具自动创建。一个箱子告诉你实际的覆盖范围
- 测试用例或测试台可以分层引用这些覆盖点，以便您可以查询是否发生了某些值或场景。

图26.1给出了覆盖组和覆盖点的基本概述。
![26.1][Img/26.1.png]
                               Fig.26.1 "covergroup" and "coverpoint"——Basics

## 26.2 System Verilog "覆盖组"：基础

图26.1及其注释不言自明。指出了covergroup和coverpoint的关键语法。需要重申的几点如下。
























